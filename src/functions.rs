use anyhow::Result;
use std::{fs::File, io::Write, path::PathBuf, process::Command};

pub fn create_sys_crate(name: &str) -> Result<()> {
    let sys_name = &format!("{}-sys", name);

    println!("Creating -sys crate at {}...", sys_name);
    Command::new("cargo")
        .args(["new", "--lib", sys_name])
        .output()?;

    println!("Adding dependencies...");
    Command::new("cargo")
        .args(["add", "cty"])
        .current_dir(sys_name)
        .output()?;

    println!("Adding build dependencies...");
    Command::new("cargo")
        .args(["add", "--build", "bindgen", "cc"])
        .current_dir(sys_name)
        .output()?;

    Ok(())
}

pub fn find_source_files(name: &str, source_name: &str) -> Result<Vec<String>> {
    let mut source_name = source_name.to_owned();
    source_name.push_str("/Makefile");
    let vec = std::fs::read_to_string(source_name)?
        .lines()
        .map(|line| line.to_owned())
        .enumerate()
        .collect::<Vec<_>>();

    let mut i = 0;
    while !vec[i].1.starts_with("C_SOURCES") {
        i += 1;
    }
    let start = i;

    while vec[i].1.ends_with('\\') {
        i += 1
    }
    let end = i;

    Ok(vec
        .into_iter()
        .filter(|(i, _)| start < *i && *i < end + 1)
        .map(|(_, line)| format!("../{}/{}", name, line.trim_matches('\\').trim().to_owned()))
        .collect())
}

pub fn create_build_rs(name: &str, sources: Vec<String>) -> Result<()> {
    let mut libname = name.to_owned();
    libname.push_str("-sys/build.rs");
    let libname = PathBuf::from(libname);
    let mut file = File::create(&libname)?;

    let build_script = format!(
        r#"/* Generated by cube-rs */
use std::env;
use std::path::PathBuf;

fn main() {{
    let c_sources = vec!{0:?};

    // create the cube library
    let mut build = cc::Build::new();
    for entry in c_sources {{
        build.file(entry);
    }}
    build.compile("{1}");

    println!("cargo:rustc-link-lib=static={1}");
    println!("cargo:rustc-link-search=native=.");
    println!("cargo:rerun-if-changed=lib{1}.a");

    // The bindgen::Builder is the main entry point
    // to bindgen, and lets you build up options for
    // the resulting bindings.
    let bindings = bindgen::Builder::default()
        // The input header we would like to generate
        // bindings for.
        .header("wrapper.h")
        .use_core()
        .ctypes_prefix("cty")
        // Tell cargo to invalidate the built crate whenever any of the
        // included header files changed.
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        // Finish the builder and generate the bindings.
        .generate()
        // Unwrap the Result and panic on failure.
        .expect("Unable to generate bindings");

    // Write the bindings to the $OUT_DIR/bindings.rs file.
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}}"#,
        sources, name
    );
    file.write_all(build_script.as_bytes())?;

    Ok(())
}
