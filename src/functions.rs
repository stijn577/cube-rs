use std::{path::PathBuf, process::Command};
use CubeParseError::*;

// pub fn create_build_rs(name: &str, includes: Vec<String>, sources: Vec<String>) -> Result<()> {
//     let mut libname = name.to_owned();
//     libname.push_str("-sys/build.rs");
//     let libname = PathBuf::from(libname);
//     let mut file = File::create(&libname)?;

//     let build_script = format!(
//         r#"/* Generated by cube-rs */
// use std::env;
// use std::path::PathBuf;

// fn main() {{
//     let c_sources = vec!{0:?};

//     // create the cube library
//     let mut build = cc::Build::new();
//     for entry in c_sources {{
//         build.file(entry);
//     }}
//     build.compile("{1}");

//     println!("cargo:rustc-link-lib=static={1}");
//     println!("cargo:rustc-link-search=native=.");
//     println!("cargo:rerun-if-changed=lib{1}.a");

//     // The bindgen::Builder is the main entry point
//     // to bindgen, and lets you build up options for
//     // the resulting bindings.
//     let bindings = bindgen::Builder::default()
//         // The input header we would like to generate
//         // bindings for.
//         .header("wrapper.h")
//         .use_core()
//         .ctypes_prefix("cty")
//         // Tell cargo to invalidate the built crate whenever any of the
//         // included header files changed.
//         .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
//         // Finish the builder and generate the bindings.
//         .generate()
//         // Unwrap the Result and panic on failure.
//         .expect("Unable to generate bindings");

//     // Write the bindings to the $OUT_DIR/bindings.rs file.
//     let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
//     bindings
//         .write_to_file(out_path.join("bindings.rs"))
//         .expect("Couldn't write bindings!");
// }}"#,
//         sources, name
//     );
//     file.write_all(build_script.as_bytes())?;

//     Ok(())
// }

pub struct CubeProjectParser {
    crate_name: String,
    project: PathBuf,
    cached: Vec<(usize, String)>,
}

impl CubeProjectParser {
    pub fn new(
        mut crate_name: String,
        mut project: PathBuf,
    ) -> Result<CubeProjectParser, CubeParseError> {
        crate_name.push_str("-sys");
        project.push("./Makefile");
        let makefile = project.canonicalize().unwrap();

        let makefile_contents = std::fs::read_to_string(makefile.clone())
            .map_err(|_| FileNotFound(makefile))?
            .lines()
            .map(|line| line.to_owned())
            .enumerate()
            .collect::<Vec<_>>();

        Ok(Self {
            crate_name,
            project,
            cached: makefile_contents,
        })
    }

    pub fn create_sys_crate(&self) -> Result<(), CubeParseError> {
        println!("Checking if crate {} already exists...", self.crate_name);
        if std::fs::read_dir(&self.crate_name).is_err() {
            println!("{} does not yet exist, creating it now...", self.crate_name);
            let mut commands = vec![];
            commands.push(
                Command::new("cargo")
                    .args(["new", "--lib", &self.crate_name])
                    .output(),
            );
            commands.push(
                Command::new("cargo")
                    .args(["add", "cty"])
                    .current_dir(&self.crate_name)
                    .output(),
            );
            commands.push(
                Command::new("cargo")
                    .args(["add", "--build", "bindgen", "cc"])
                    .current_dir(&self.crate_name)
                    .output(),
            );

            for command in commands {
                let dbg = format!("{:?}", command);
                command.map_err(|_| CargoFailedError(dbg))?;
            }
        } else {
            println!("{} exists already, ignoring...", self.crate_name)
        }

        Ok(())
    }

    pub fn makefile_variable(&self, name: &str) -> Result<(), CubeParseError> {
        let (start, end) = self.find_lines(name, &self.cached)?;

        Ok(())
    }

    fn find_lines(
        &self,
        name: &str,
        cached: &[(usize, String)],
    ) -> Result<(usize, usize), CubeParseError> {
        if let Some((i, _)) = cached.iter().find(|(_, line)| line.starts_with(name)) {
            let i = *i;
            let start = i;

            if let Some((i, _)) = cached
                .iter()
                .skip(i)
                .find(|(_, line)| line.trim().is_empty())
            {
                Ok((start, *i))
            } else {
                Err(EntryNotFound(name.to_owned()))
            }
        } else {
            Err(EntryNotFound(name.to_owned()))
        }
    }
}

#[derive(thiserror::Error, Debug)]
pub enum CubeParseError {
    #[error("The filed {0} could not be found!")]
    FileNotFound(PathBuf),
    #[error("Failed to execute cargo command: {0}")]
    CargoFailedError(String),
    #[error("Failed to find entry '{0}' in Makefile.")]
    EntryNotFound(String),
}

// Ok(makefile
//     .into_iter()
//     .filter(|(i, _)| start < *i && *i < end + 1)
//     .map(|(_, line)| {
//         format!(
//             "../{}/{}",
//             source_name.to_str().unwrap(),
//             line.trim_matches('\\').trim().to_owned()
//         )
//         .replace(".\\", "")
//         .replace("\\", "")
//     })
//     .collect())
